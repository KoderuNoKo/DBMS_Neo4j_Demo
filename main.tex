\documentclass{article}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue]{hyperref}
\usepackage{enumitem}
\geometry{a4paper, margin=1in}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\lstdefinestyle{SQL}{
  language=SQL,
  backgroundcolor=\color{gray!10},
  keywordstyle=\color{blue}\bfseries,
  stringstyle=\color{orange},
  commentstyle=\color{gray},
  basicstyle=\ttfamily\small,
  showstringspaces=false,
  breaklines=true
}


\begin{document}

\section{PostgreSQL Transactions}

Add a few rows so we can test:

\begin{lstlisting}[style=SQL]
INSERT INTO Movie VALUES
(1, 'Inception', 'Action|Sci-Fi'),
(2, 'Titanic', 'Drama|Romance');

INSERT INTO Rating VALUES
(1, 1, 4.5, 1730000000),
(2, 1, 5.0, 1730000001),
(1, 2, 3.0, 1730000002);
\end{lstlisting}

\subsection{Atomicity}

We open 2 sections, A and B

\begin{lstlisting}[style=SQL, caption={Session A}]
BEGIN;
INSERT INTO Movie VALUES (3, 'Avatar', 'Action|Adventure');
\end{lstlisting}

\begin{lstlisting}[style=SQL, caption={Session B}]
SELECT * FROM Movie WHERE movieId = 3;
\end{lstlisting}

When we run session B, we get no results because we haven't commited in session A yet 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{1.png}
    \label{fig:example}
\end{figure}

When we commited in session A

\begin{lstlisting}[style=SQL, caption={Session A}]
COMMIT;
\end{lstlisting}

and we run session B again

\begin{lstlisting}[style=SQL, caption={Session B}]
SELECT * FROM Movie WHERE movieId = 3;
\end{lstlisting}

we get the 1 row as the result

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{2.png}
    \label{fig:example}
\end{figure}

Now we try rollback

\begin{lstlisting}[style=SQL, caption={Session A}]
BEGIN;
INSERT INTO Movie VALUES (4, 'Gladiator', 'Action|Drama');
SELECT * FROM Movie WHERE movieId = 4;
\end{lstlisting}

When we run this session, we get this row as a result

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{3.png}
    \label{fig:example}
\end{figure}

But when we rollback

\begin{lstlisting}[style=SQL, caption={Session A}]
ROLLBACK;
\end{lstlisting}

and run this code again in the same session

\begin{lstlisting}[style=SQL, caption={Session A}]
SELECT * FROM Movie WHERE movieId = 4;
\end{lstlisting}

we get nothing as a result

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{1.png}
    \label{fig:example}
\end{figure}

\subsection{Consistency}

\begin{lstlisting}[style=SQL]
BEGIN;
INSERT INTO Rating VALUES (9, 99, 4.0, EXTRACT(EPOCH FROM now())::bigint);
\end{lstlisting}

When we try to add a new role that violates foreign key constraint, it gives us an error message

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{4.png}
    \label{fig:example}
\end{figure}

Normally we should use \texttt{ROLLBACK;} to prevent any errors that could occur


\subsection{Isolation}

Isolation levels control how concurrently executing transactions interact. PostgreSQL supports \texttt{READ COMMITTED, REPEATABLE READ} and \texttt{SERIALIZABLE}. We will try the \texttt{READ COMMITED} isolation level, which is default in PostgreSQL

\begin{lstlisting}[style=SQL, caption={Session A}]
BEGIN;
SELECT rating FROM Rating WHERE userId = 1 AND movieId = 1;
\end{lstlisting}

When we run this in session A, it gives us this result

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{5.png}
    \label{fig:example}
\end{figure}

then we run this in session B

\begin{lstlisting}[style=SQL, caption={Session B}]
UPDATE Rating SET rating = 1.0 WHERE userId = 1 AND movieId = 1;
COMMIT;
\end{lstlisting}

and run this in session A

\begin{lstlisting}[style=SQL, caption={Session A}]
SELECT rating FROM Rating WHERE userId = 1 AND movieId = 1;
\end{lstlisting}

we get a new result

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{6.png}
    \label{fig:example}
\end{figure}

This is because session A sees the updated rating in the second \texttt{SELECT} because \texttt{READ COMMITTED} fetches the latest committed data for each statement.
\subsection{Durability}

Once a transaction commits, it will survive system crashes, thanks to WAL (Write-Ahead Logging). For example

\begin{lstlisting}[style=SQL]
BEGIN;
INSERT INTO Movie(movieId, title, genres)
VALUES (99, 'DurabilityTest', 'Sci-Fi');

COMMIT;
\end{lstlisting}

After we run the code, we restart PostgreSQL and query

\begin{lstlisting}[style=SQL]
SELECT * FROM Movie WHERE movieId = 99;
\end{lstlisting}

we still get the correct result

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{7.png}
    \label{fig:example}
\end{figure}


\end{document}

